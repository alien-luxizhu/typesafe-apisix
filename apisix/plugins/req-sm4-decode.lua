---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by luxizhu.
--- DateTime: 2021/4/14 14:08
--- 请求体解密
--- 必须将优先级设得最高，最先执行，率先将包体解密
---

local ngx = ngx
local setmetatable = setmetatable
local string = string
local tonumber = tonumber
local fopen = io.open
local type = type

require("util.misc")
local mine_logger = require("util.logger")
local logger = mine_logger.default
local config = require("conf.access-service-config")
local mylib = require("util.cipher")
local cjson = require "cjson.safe"

local schema = {}
local plugin_name = "req-sm4-decode"

local _M = {
    version = 0.1,
    priority = 999999,
    name = plugin_name,
    schema = schema,
}

function _M.check_schema(conf, schema_type)
    return true
end

local function sm4_decode(str)
    return mylib.base64_sm4_decrypt(str, config.sm4keyfield, config.sm4iv)
end

---@field ctx api_ctx
---@field seq_no string
---@class AccessNew
local AccessNew = {}

function AccessNew.new(ctx)
    local self = {
        ctx = ctx,
        seq_no = ctx.var.http_msgid or "-",
    }
    return setmetatable(self, { __index = AccessNew })
end

---@param headerVersion_s string @ "xxx-4.4.0"
---@param configAgentVersion string
---@return boolean
function AccessNew:agentVersionCompare(headerVersion_s, configAgentVersion)
    if not string.find(configAgentVersion, "-") then
        -- 如果agent_version="4.4.0"
        configAgentVersion = "agent-" .. configAgentVersion
    end

    local _, a, b, c = string.match(headerVersion_s, "(%w+)-(%d+).(%d+).(%d+)")
    local _, v1, v2, v3 = string.match(configAgentVersion, "(%w+)-(%d+).(%d+).(%d+)")

    ngx.log(ngx.DEBUG, string.format("headerVersion_s %s.%s.%s --> %s.%s.%s", a, b, c, v1, v2, v3))
    logger:INFO_RUN_LOG(self.seq_no, "headerVersion_s %s.%s.%s --> %s.%s.%s", a, b, c, v1, v2, v3)

    -- 全部转成整数
    a, b, c = tonumber(a or "0"), tonumber(b or "0"), tonumber(c or "0")
    v1, v2, v3 = tonumber(v1 or "0"), tonumber(v2 or "0"), tonumber(v3 or "0")

    --- 用相同格式字符串比较版本号
    local fmt = "%03d.%03d.%03d"
    return string.format(fmt, a, b, c) >= string.format(fmt, v1, v2, v3)
end

function AccessNew:checkAgentVersion()
    local headerVersion_s = self.ctx.var.http_agent or ""
    local seq_no = self.seq_no
    if headerVersion_s == "" then
        logger:INFO_RUN_LOG(seq_no, "HTTP_AGENT is empty ")
        return false
    end

    local configAgentVersion = config.min_auth_version or "5.0.0"
    if self:agentVersionCompare(headerVersion_s, configAgentVersion) then
        logger:INFO_RUN_LOG(seq_no, "http_agent is %s >= config_agent is %s", headerVersion_s, configAgentVersion)
        return true
    else
        logger:INFO_RUN_LOG(seq_no, "http_agent is %s < config_agent is %s", headerVersion_s, configAgentVersion)
        return false
    end
end

function _M.get_req_body()
    ngx.req.read_body()
    local body_str = ngx.req.get_body_data()
    if not body_str then
        local file_name = ngx.req.get_body_file()
        if not file_name then
            return
        end
        --- 从文件读包体
        logger:RUN_LOG(self.seq_no, "get body from file is %s", file_name)
        local f = fopen(file_name, "r")
        body_str = f:read("*all")
        f:close()
    end
    return body_str
end

function AccessNew:decrypt_body()
    if not self:checkAgentVersion() then
        return
    end

    local ctx = self.ctx
    if not "POST" == ctx.var.request_method then
        return
    end

    local body_str = _M.get_req_body() or ""
    if #body_str == 0 then
        return
    end

    local seq_no = self.seq_no
    local t, err = cjson.decode(body_str)
    if not t then
        err = string.format("decode body error %s %s %s", ctx.var.uri, err, body_str)
        logger:RUN_LOG(seq_no, err)
        -- 发现ngx.print会导致返回status为200
        -- ngx.print(err)
        return ngx.HTTP_UNAUTHORIZED
    end

    if type(t) ~= "table" then
        logger:RUN_LOG(seq_no, "body error: not json object")
        return ngx.HTTP_UNAUTHORIZED
    end

    if not t.cTxt then
        err = string.format("body error cTxt not found, %s %s", ctx.var.uri, body_str)
        logger:RUN_LOG(seq_no, err)
        return ngx.HTTP_UNAUTHORIZED
    end

    body_str = sm4_decode(t.cTxt)
    ngx.req.init_body()
    ngx.req.append_body(body_str)
    ngx.req.finish_body()

    --for debug
    --return 200, ngx.req.get_body_data()
end

function _M.is_skip()
    --- 如果配置skip_body_sm4decode_uri跳过body解密， 在此直接返回
    for _, skip_uri in ipairs(config.skip_body_sm4decode_uri or {}) do
        if string.match(ngx.var.document_uri, skip_uri) then
            return true
        end
    end
end

function _M.access(conf, ctx)
    if _M.is_skip() then
        return
    end
    return AccessNew.new(ctx):decrypt_body()
end

return _M